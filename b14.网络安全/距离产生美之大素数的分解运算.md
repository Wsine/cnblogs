# 距离产生美之大素数的分解运算

### 目标

已知模数N的值，p,q是一个随机数R附近的质数，且满足下式：
$$| p-q | < 2\sqrt[4]{n}$$
目标：对RSA模数N = pq作因式分解，求出p、q的值

### 程序要求

- gcc编译环境
- gmp大数运算库

### 代码解析

伪代码为：
$BEGIN$
$$A = \lceil{\sqrt{n}}\ \rceil$$
$$X = \sqrt{A^2-N}$$
$$p = A - x$$
$$q = A + x$$
$END$

代码实现为：

```
#include <gmp.h>

int main() {
	/* declare variants */
	mpz_t N, A, p, q, x, one, temp;
	/* init variants */
	mpz_init_set_str(N, "17976931348623159077293051907890"
	                    "24733617976978942306572734300811"
	                    "57732675805505620686985379449212"
	                    "98295958550138753716401571013985"
	                    "86478337786069255834975410851965"
	                    "91615128057575940752635007475935"
	                    "28871082364994994077189561705436"
	                    "11494748650467110151015639406805"
	                    "27540071584560878577663743040086"
	                    "340742855278549092581", 10);
	mpz_init(A);	mpz_init(x);
	mpz_init(p);	mpz_init(q);
	mpz_init_set_si(one, 1);
	mpz_init(temp);
	/* sqrt(N) */
	mpz_sqrt(temp, N);
	/* A = ceil(sqrt(N)) */
	mpz_add(A, temp, one);
	/* A * A */
	mpz_mul(temp, A, A);
	/* A * A - N */
	mpz_sub(temp, temp, N);
	/* x = sqrt(A * A - N) */
	mpz_sqrt(x, temp);
	/* p = A - x */
	mpz_sub(p, A, x);
	/* q = A + x */
	mpz_add(q, A, x);
	/* print p and q */
	gmp_printf("Factor N result is :\n");
	gmp_printf("  p = %Zd\n", p);
	gmp_printf("  q = %Zd\n", q);
	/* exit */
	return 0;
}
```

简单点来说呢，就是根据右边这个伪代码为流程写的。这个需要计算A= ⌈√N⌉，如果正常的运算，会造成浮点溢出异常。但是，由于声明的类型都是大整数，因此开方后的结果一定会是整数，小数部分会被过滤，再进行+1操作，就是伪代码中的向上取整的操作。剩下的操作，就按照流程运行就是了，最后输出结果。
注意:GMP库声明的变量都需要初始化。（好想知道它是怎么实现的，一定用了泛型编程的思想）

### 后记

从这次的实验中，应该就是从大整数的角度来看待RSA密钥的复杂性，更准确点来说，由于是大整数，在不知道密钥的情况下，暴力枚举破解这个密钥所需要花费的时间是远远大于使用密钥加密的内容的时效性的，充分说明且体验了RSA密钥的密钥生成和分解的密钥的难度。

传送门：[下载](http://pan.baidu.com/s/1i5k6SIh)